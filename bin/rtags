#!/usr/bin/env ruby
#
#   rtags is a Ruby replacement for ctags - allowing for name navigation in
#   source code using vim, emacs and others.
#   
#   by Keiju ISHITSUKA and Pjotr Prins
#   
#   LICENSE: RUBY LICENSE - see file LICENSE.TXT
#   INSTALL: see file README
#   RELEASE NOTES: see file RELEASENOTES

RTAGS_VERSION='0.93 (August 2006)'

require 'optparse'
require 'ostruct'

usage = <<USAGE

        rtags #{RTAGS_VERSION} (Ruby tags) by Keiju ISHITSUKA
				  improvements by Pjotr Prins
        
        A Ruby tool for using Ruby tags rendering more tags than
        other tools for use with vim or emacs
        
        http://rubyforge.org/projects/rtags/ - maintainer Pjotr Prins

        usage:

                rtags [--vi] filenames
                rtags --help

        by default creates an emacs tags file. With the --vi switch
        a vim tags file is created instead.

USAGE


$options = OpenStruct.new()
$options.warning_level = 0

opts = OptionParser.new() { |opts|
  opts.on_tail("-h", "--help", "Print this message") {
     print(usage)
    print(opts)
    print <<EXAMPLE
    
Examples:

    rtags *.rb
    rtags --vi -f vim_tags *.rb
    
EXAMPLE
    exit()
  }
   
  opts.on("-f tagfile", String, "Output to tagfile (default 'TAGS')") do | s |
    $options.tagfile = s
  end
  opts.on("-a", "append mode") do 
    $options.tagfile_mode = 'a'
  end
  opts.on("-w level", Integer, "Warning level (default 0)") do | w |
    $options.warning_level = w
  end
  opts.on("--vi", "Use vi type tags (default is emacs)") do 
    $options.vi = true
  end
  opts.on("--quiet", "Quiet mode") do 
    $options.quiet = true
  end
  opts.on("--debug", "Debug output to stdout") do 
    $options.debug = true
  end
  opts.on("--debug_tokens", "Debug token information to stdout") do 
    $options.debug_tokens = true
  end
}
opts.parse!(ARGV)

if $options.tagfile == nil
  if $options.vi
    $options.tagfile = 'tags' 
  else
    $options.tagfile = 'TAGS' 
  end
end
$options.tagfile_mode = 'w' if $options.tagfile_mode == nil
$options.warning_level = -1 if $options.quiet

print "\nrtags.rb #{RTAGS_VERSION} writing to file '#{$options.tagfile}'\n" if !$options.quiet

require "e2mmap"
require "tracer"

require "irb/ruby-lex"
require "irb/ruby-token"

module RTAGS
  @RCS_ID='-rtags.rb 0.92-'

  class RTToken
    def initialize(readed, context, name, token)
      @readed = readed
      @context = context
      @name = name
      @token = token
    end
    attr :readed
    attr :context
    attr :name
    attr :token

    def line_no
      @token.line_no
    end

    def seek
      @token.seek
    end

    def to_s
      "#{def_name} #{abs_name} in #{token.inspect}"
    end
  end

  class RTModule < RTToken
    def abs_name
      (context || "") + "::" + name
    end
    
    def def_name
      "module"
    end
  end

  class RTClass < RTModule
    def abs_name
      (context || "") + "::" + name
    end

    def def_name
      "class"
    end
  end

  class RTSingleClass < RTClass
    def abs_name
      (context || "") + "<<" + name
    end

    def def_name
      "class"
    end
  end

  class RTMethod < RTToken
    def abs_name
      (context || "") + "#" + name
    end

    def def_name
      "def"
    end
  end
  class RTAlias < RTMethod
    def def_name
      "alias"
    end
  end
  class RTAttr < RTMethod
    def def_name
      "attr"
    end
  end

  class RTSingleMethod < RTToken
    def abs_name
      (context || "") + "." + name
    end

    def def_name
      "def"
    end
  end
  class RTSingleAlias < RTSingleMethod
    def def_name
      "alias"
    end
  end
  class RTSingleAttr < RTSingleMethod
    def def_name
      "attr"
    end
  end
  
  class Parser
    include RubyToken

    def initialize(file_name)
      @size = 0
      @input_file_name = file_name
      @scanner = RubyLex.new
      @scanner.exception_on_syntax_error = false
      # @scanner.skip_space = true
      # @scanner.readed_auto_clean_up = true
      #parse_statements
    end

		def warn s,level=0,token=nil,extra=nil
			if level <= $options.warning_level
	      $stderr.print "\nWarn: #{s} in <#{@input_file_name}> "
				if token
	  	    $stderr.print "in line #{token.line_no}, pos #{token.char_no}"
					# $stderr.print "by name <#{token.name}>" if token and token.name
					$stderr.print "\n"
				end
				if $options.debug
    	  	$stderr.print "context=",context if context
      		$stderr.print "Token=",token.inspect,"\n" if token
      		$stderr.print extra if extra
				end
			end
		end

    def scan(&block)
      print "\nParsing #{@input_file_name}..." if !$options.quiet
      File.open(@input_file_name) do |input|
        @tokens = []
        @unget_readed = []
        @readed = []
        @scanner.set_input(input)
        parse_statements(&block)
      end
    end

		# get the next token - fetching it from the temporary +@tokens+
		# stack if it is not empty
		
    def get_tk
      if @tokens.empty?
        tk = @scanner.token
        @readed.push @scanner.get_readed
        $stderr.print tk.inspect if $options.debug_tokens
        tk
      else
        @readed.push @unget_readed.shift
        tk = @tokens.shift
        $stderr.print tk.inspect if $options.debug_tokens
        tk
      end
    end

		# lookahead returning the next token without popping it
    def peek_tk
      unget_tk(tk = get_tk)
      tk
    end

		# push the token +tk+ back onto the stack
    def unget_tk(tk)
      @tokens.unshift tk
      @unget_readed.unshift @readed.pop
    end

    def skip_tkspace(skip_nl = true)
      tokens = []
      while ((tk = get_tk).kind_of?(TkSPACE) ||
             (skip_nl && tk.kind_of?(TkNL)))
        tokens.push tk
      end
      unget_tk(tk)
      tokens
    end

		# returns the actual token string as it was read and 
		# sets the read buffer to zero length
    def get_tkreaded
      readed = @readed.join("")
      @readed = []
      readed
    end

    NORMAL = "::"
    SINGLE = "<<"

    def parse_statements(context = nil, single = NORMAL, &block)
      begin
				last_seekpos = -1
        nest = 1

        while tk = get_tk
          case tk
          when TkCLASS
            parse_class(context, single, tk, &block)
          when TkMODULE
            parse_module(context, single, tk, &block)
          when TkDEF
            nest += 1
            parse_method(context, single, tk, &block)
          when TkALIAS
            parse_alias(context, single, tk, &block)
          when TkCASE,
               TkDO,
                TkFOR,
               TkIF,
               TkUNLESS,
               TkUNTIL,
                 TkWHILE, 
               TkBEGIN
            nest += 1
          when TkIDENTIFIER
             case tk.name
             when "attr"
              parse_attr(context, single, tk, &block)
            when /^attr_(reader|writer|accessor)$/
              parse_attr_accessor(context, single, tk, &block)
            end
          when TkEND
            return if (nest -= 1) == 0
          end
          begin
            get_tkreaded
            skip_tkspace(false) # don't skip newlines
						# prevent endless loop (tokenizer does not always behave
						# at eof)
						seekpos = peek_tk.seek
					  if last_seekpos == seekpos
							warn('bailing out early',0,tk)
            	return
						end
						last_seekpos = seekpos
          end while peek_tk == TkNL
					# p [@input_file_name, peek_tk]
        end
      rescue
				warn('parse error',0,tk,$!)
      end
    end

    def parse_class(context, single, tk, &block)
      skip_tkspace
      case name_t = get_tk
      when TkCONSTANT
        name = name_t.name
        if single == SINGLE
          yield RTSingleClass.new(get_tkreaded, context, name, tk)
        else
          yield RTClass.new(get_tkreaded, context, name, tk)
        end
        parse_statements((context || "") + single + name, &block)

      when TkLSHFT
        skip_tkspace
        case name_t2 = get_tk
        when TkSELF
          parse_statements(context, SINGLE, &block)
        when TkCONSTANT
#          yield RTSingleClass.new(get_tkreaded, context, name_t2.name, tk)
          parse_statements((context || "") + "::" + name_t2.name, 
                           SINGLE, 
                           &block)
        else
					warn('unrecognised token',1,name_t2)
        end
      else
				warn('unrecognised token',1,name_t2)
      end
    end

    def parse_module(context, single, tk, &block)
      skip_tkspace
      name = get_tk.name
      yield RTModule.new(get_tkreaded, context, name, tk)
      parse_statements((context||"") + single + name, &block)
    end

    def parse_method(context, single, tk, &block)
      skip_tkspace
      name_t = get_tk
      back_tk = skip_tkspace

      if (dot = get_tk).kind_of?(TkDOT)
        # tricky tech.
        @scanner.instance_eval{@lex_state = EXPR_FNAME}
        skip_tkspace
        name_t2 = get_tk
        case name_t
        when TkSELF
          name = name_t2.name
        when TkId
          if context and 
              context =~ /^#{name_t.name}$/ || context =~ /::#{name_t.name}$/
            name = name_t2.name
          else
            context = (context || "") + "::" + name_t.name
            name = name_t2.name
          end
        else
					warn('unrecognised token',1,name_t2)
          break
        end
        yield RTSingleMethod.new(get_tkreaded, context, name, tk)

      else
        unget_tk dot
        back_tk.reverse_each do
          |tk|
          unget_tk tk
        end
        name = name_t.name
        if single == SINGLE
          yield RTSingleMethod.new(get_tkreaded, context, name, tk)
        else
          yield RTMethod.new(get_tkreaded, context, name, tk)
        end
      end
    end

    def parse_alias(context, single, tk, &block)
      skip_tkspace
      name = get_tk.name
      if context
        if single == SINGLE
          yield RTSingleAlias.new(get_tkreaded, context, name, tk)
        else
          yield RTAlias.new(get_tkreaded, context, name, tk)
        end
      else
        if single == SINGLE
          yield RTSingleAlias.new(get_tkreaded, "main", name, tk)
        else
          yield RTAlias.new(get_tkreaded, nil, name, tk)
        end
      end
    end

    def parse_attr(context, single, tk, &block)
      args = parse_symbol_arg(1)
      if args.size > 0
        name = args[0]
        if context
          if single == SINGLE
            yield RTSingleAttr.new(get_tkreaded, context, name, tk)
          else
            yield RTAttr.new(get_tkreaded, context, name, tk)
          end
        else
          if single == SINGLE
            yield RTSingleAttr.new(get_tkreaded, "main", name, tk)
          else
            yield RTAttr.new(get_tkreaded, nil, name, tk)
          end
        end
      else
				warn('token not recognized - next attr arg size == zero',1)
      end    
    end

    def parse_attr_accessor(context, single, tk, &block)
      args = parse_symbol_arg
      readed = get_tkreaded
      for name in args
        if context
          if single == SINGLE
            yield RTSingleAttr.new(readed, context, name, tk)
          else
            yield RTAttr.new(readed, context, name, tk)
          end
        else
          if single == SINGLE
            yield RTSingleAttr.new(readed, "main", name, tk)
          else
            yield RTAttr.new(readed, nil, name, tk)
          end
        end
      end    
    end

    def parse_symbol_arg(no = nil)
      args = []
      skip_tkspace
      case tk = get_tk
      when TkLPAREN
        loop do
          skip_tkspace
          if tk1 = parse_symbol_in_arg
            args.push tk1
            break if no and args.size >= no
          end

          skip_tkspace
          case tk2 = get_tk
          when TkRPAREN
            break
          when TkCOMMA
          else
					  warn('token not recognized in funargs',1,tk)
            break
          end
        end
      else
        unget_tk tk
        if tk = parse_symbol_in_arg
          args.push tk
          return args if no and args.size >= no
        end

        loop do
          skip_tkspace(false)
          case tk1 = get_tk
          when TkCOMMA
          when TkNL
            unget_tk tk1
            break
          else
					  warn('token not recognized in funargs',1,tk1)
            break
          end
          skip_tkspace
          if tk = parse_symbol_in_arg
            args.push tk
            break if no and args.size >= no
          end
        end
      end
      args
    end

    def parse_symbol_in_arg
      case tk = get_tk
      when TkSYMBEG
        case tk = get_tk
        when TkCONSTANT, 
            TkIDENTIFIER,
            TkFID
          tk.name
        else
					warn('token not recognized; next SYMBEG ',1,tk)
          nil
        end
      when TkSTRING
        eval @readed[-1]
      else
				warn('token not recognized; next SYMBEG and STRING ',1,tk) if $options.debug 
        nil
      end
    end
  end

  class TAGS
    def initialize(files)
      @files = files
    end
  end

  class EMACS_TAGS < TAGS
    def shipout
      open($options.tagfile, $options.tagfile_mode) do
        |@output|

        for fn in @files
          output = []
          size = 0

          $stderr.printf "--\n-- parse file: %s\n", fn if $options.debug
          parser = Parser.new(fn)
          parser.scan do
            |tk|
            $stderr.print tk, "\n" if $options.debug
            item = sprintf("%s\C-?%s\C-A%d,%s\n",
                           tk.readed,
                           tk.abs_name,
                           tk.line_no,
                           tk.seek)
            output.push item
            size += item.size
          end
          @output.print "\C-L\n#{fn},#{size}\n"
          @output.print output.join
        end
      end
    end
  end

  class VI_TAGS < TAGS
    def shipout
      output = []
      for fn in @files
        $stderr.printf "--\n-- parse file: %s\n", fn if $options.debug
        parser = Parser.new(fn) 
        parser.scan do
          |tk|
          $stderr.print tk, "\n" if $options.debug
          output.push sprintf("%s\t%s\t/^%s/\n",
                                tk.name,
                                fn,
                                tk.readed)
          output.push sprintf("%s\t%s\t/^%s/\n",
                                tk.abs_name,
                                fn,
                                tk.readed)
        
        end
      end
      open($options.tagfile, $options.tagfile_mode) do
        |out|
        out << output.sort!
      end
    end
  end
end

if ARGV.size == 0 or ARGV[0] == '--help'
        ARGV.shift
        print usage
        exit 1
end

if $options.vi
  tags = RTAGS::VI_TAGS.new(ARGV)
else
  tags = RTAGS::EMACS_TAGS.new(ARGV)
end
tags.shipout


